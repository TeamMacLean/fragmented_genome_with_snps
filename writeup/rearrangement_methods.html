<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Rearrangement Methods</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>





</head>

<body>
<h1>Rearrangement Methods</h1>

<h2>What I am trying to acheive:</h2>

<ul>
<li><p>I have a list of identifiers for my fragments in their original order, and a list of those same frag ids arranged in order of SNP density (ascending)</p></li>
<li><p>With real data, the frags would be assigned ids before being put into a fasta file. With my data the ids are named according to the original sequence order, and I have shuffled them before creating a fasta file, so the original order is not simply the same as the order in the fasta file.</p></li>
<li><p>I need to design an algorithm that will rearrange the disordered frags into their proper order, based on SNP density/position data</p></li>
<li><p>This hasn&#39;t been done before, so I will need to test a variety of rearrangement methods and I will need a way of ranking them by their effectiveness</p></li>
<li><p>Once I have several methods to compare, I can plot an effectiveness score for each arrangement. The scores of the density order and random rearrangements can be used as controls</p></li>
<li><p>The aim is to create a rearrangement method which can later be used to determine the likely position of a phenotype altering mutant SNP, based on the distribution of SNPs in the sequence: see the repository <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/README.md">README</a> for more information.</p></li>
<li><p>I have set up my model genome so that the mutant is at the mid-point (100,000) of a 200Kb sequence, around which a normal ditribution of SNPs are centred</p></li>
<li><p>Once I have a rearrangement method that is succesful at determining the mutant position in my model genome, I can modify that method for models with different mutant positions, by varying the midpoint the method uses to distribute the fragments around.</p></li>
<li><p>Then I will write a method to be used with real data, that will determine the mutant position. This will perform the succesful rearrangement method from before multiple times, with different midpoints, in order to find the most likely true mutant position.</p></li>
</ul>

<h2>Data used</h2>

<p>I used data held in <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/fasta_vcf/snps.vcf">this VCF</a> and <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/fasta_vcf/frags_shuffled.fasta">this fasta</a> file, which are generated from my model genome (see <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/README.md">README</a>). The information neccesary for the rearrangement methods below was extracted from the fasta and VCF in <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/density_method_testa.rb">density_method_testa.rb</a>, and the rearrangement methods themselves can be found in <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/rearrangement_methods.rb">rearrangement_methods.rb</a>.</p>

<h2>Ranking the rearrangement methods</h2>

<p>I have come up with a way of giving each rearrangement method a score. See the ruby method: <strong>score</strong>, in <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/rearrangement_methods.rb">rearrangement_methods.rb</a>. A simple way of defining what this method does is: taking away the index of each fragment in the original order, from it&#39;s new index in the rearranged list - this gives the &ldquo;distance&rdquo;&ldquo; that the fragment has moved when re-ordered (as an absolute value) - these &quot;distances&rdquo; are then summed to give an overall score, which mathematically can be described as the ordinal similarity between the two arrangements. The higher the value of the score, the lower the ordinal similarity (the less similar the two orders are). A perfect score would be 0, where the two orders are identical.</p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/ordinal_similarity.png?raw=true" alt="Image"/></p>

<p><a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/ordinal_similarity.png">Figure1</a></p>

<p>where:</p>

<ul>
<li>a = (1&hellip;n)</li>
<li>i = each element of a</li>
<li>F = the function used to generate the rearranged order (i.e. the method)</li>
</ul>

<p><strong>The max score will be achieved by comparing the original fragment order to a an arrangement that minimizes the ordinal similarity.</strong></p>

<p>The highest score for my fragments is 858,050 (for 1310 fragments). This is the score given when the rearranged fragment order is simply the reverse of the original order. I know that reversing the order should give the minimum ordinal similarity vs the original order because of the following:</p>

<p>Determining the maximum value for the score can be shown as an assignment problem, which is a type of linear programming. Each fragment from the original order must be assigned a new position. Each of these new positions can be thought of as a &ldquo;task&rdquo; that must be assigned to one of the fragments. The cost of each assignment varies depending on the fragment&#39;s original position, and the new position it has been assigned to. Figure 2 below, demonstrates what I mean by constructing a cost matrix for a sequence of four fragments (A, B, C and D).</p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/cost_matrix.png?raw=true" alt="Image"/></p>

<p><a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/cost_matrix.png">Figure 2</a></p>

<p>The costs shown in <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/cost_matrix.png">fig.2</a> are equivalent to: the &ldquo;distance&rdquo; a fragment has moved from it&#39;s original position as a negative number, plus a constant. The constant is a number, high enough that the lowest cost is &gt;= 0 (the cost associated with a fragment being as far as possible from it&#39;s original position). In this case the constant is 3.</p>

<p>This results in a matrix that attributes similarity or &ldquo;closeness&rdquo; between the original and assigned position with a high cost. An algorithm that works out the minimum cost for an assignment problem, will now be useful in determining the fragment order that gives the minimum ordinal similarity (max score). One such algorithm is the <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm">Hungarian algorithm</a> (or Kuhn-Munkres). Using the ruby gem <a href="https://github.com/pdamer/munkres">Munkres</a>, I can input the cost matrix from fig.2, and receive an output in the terminal that tells me the positions at which each fragment should go in a rearrangement to minimize the cost (and therefore the ordinal similarity).</p>

<p>For the fragments in the example (<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/cost_matrix.png">fig.2</a>), the order that mimimises the ordinal similarity when compared to the original order is: D, C, B, A. This is the reverse of A, B, C, D, and as such proves that reversing the original order of my fragments will maximize the score. See <a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/munkres_test.rb">munkres_test.rb</a> for details.</p>

<h2>Methods</h2>

<blockquote>
<h3>Control 1: Density order</h3>

<p>The first control was to compare the density order against the original. My hypothesis being that this should produce a high ordinal similarity score, because whilst the orginal order of the fragments is based on a normal distribution of SNPs, the density order has the fragments with the most SNPs towards the end of the list, and least near the start. Good rearrangemrent methods should have lower scores than this.</p>

<h3>Control 2: Random order</h3>

<p>The purpose of this control is to provide a baseline for which all other rearrangement methods should perform better than. To do this, I will create a method that arranges the fragments randomly, and call the score method. This can be repeated a large number of times (e.g. 100) and an average score for randomly ordered fragments can be determined.</p>

<h3>Method 1: Even Odd Method</h3>

<p>Since I know the original ordered sequence has a normal distribution of SNPs, it follows that the when the fragments are in the correct order, their SNP densities follow that same normal curve. Here I assume that the fragments with the highest densities should be in the middle of the distribution, with fragments of lowest densities at either end. The method takes the fragments in the even indexes of the density ordered array and adds these to a new array, so that they are still in ascending order of density. The frags at odd indexes (of the density order) are then reversed (into descending order of density), and then added to the same new array, after (ahead of) the frags from even indexes. </p>

<p>I expect this method to perform slightly better than the controls, however, it&#39;s basic nature means there may not be much of a difference. This Method does not neccesarily even put the frags on the correct &ldquo;side&rdquo; of the rearranged order (where the two sides are divided by the centre of the normal distribution), let alone in the correct positions.</p>

<h3>Method 2a: Left Right Method</h3>

<p>Here I use information derived directly from the fasta and VCF files rather than the SNP densities. I use the SNP position data for each of the fragments, to work out whether the positions are &ldquo;skewed&rdquo; to the left or right of each fragment. My hypothesis being that fragments with more SNPs on the &ldquo;left hand side&rdquo;, are likely to be from the &ldquo;right side&rdquo; of the sequence due to the normal distibution of SNPs (and vice versa). Fragments with a skew of SNPs to the left side are likely to be from a location downstream of the phenotype causing mutant, which is positioned in the region of highest SNP density (the centre of the normal distribution). Conversely, fragments with a right skew are likely to be from a location upstream of the mutant position. In both cases, each fragment&#39;s skew is relative to the direction in which the mutant is to be found, due to the sequence having a normal distribution of SNPs (which for now I am assuming is centred around the mid-point of the sequence).</p>

<p>The way I work out the &ldquo;skew&rdquo;: If the sum of the positions is &lt; half of the value produced by multiplying half the length of a fragment by the number of positions it has, this indicates a left skew and I add this fragment to a list of the fragments that should go on the right - and vice versa. I use the Even/Odd Method to add the fragments with 0 SNPs into either the &ldquo;left&rdquo; or &ldquo;right&rdquo; list. I then add both &ldquo;left&rdquo; and &ldquo;right&rdquo; into a super-array that is flattened to give the new fragment order. </p>

<p>I don&#39;t expect this method to perform well, as I have not re-ordered the fragments within the &ldquo;left&rdquo; and &ldquo;right&rdquo; sub-arrays, which are based on the order that the frags were found in the fasta file (and so are random). It should however perform better than the controls, assuming the &ldquo;skew&rdquo; of SNP positions can be used as an indication to the &ldquo;side&rdquo; of the normal distribution that a fragment is from.</p>

<h3>Method 2b: Left Right Density Method</h3>

<p>As explained above, one problem with the &ldquo;Left Right Method&rdquo; is that the frags are ordered randomly within the &ldquo;Left&rdquo; and &ldquo;Right&rdquo; arrays. There are two arguments used for the L/R Method in my script. One is a hash, with frag ids for keys, and lists (technically strings) of SNP positions for each of those frags as values. The other is an array of the frag lengths, which is in the same order as (corresponds to) the frag ids in the hash. This order is the the the order that the frags were in in the fasta file. See rearrangement_methods.rb for method details.</p>

<p>After writing a method that reordered the neccesary arguments for the L/R Method into SNP density order (see density_order in rearrangement_methods.rb), I re-ran the L/R Method with these new versions of the arguments. What this gave me was &ldquo;Left&rdquo; and &ldquo;Right&rdquo; arrays, with frag ids in ascending order of SNP density. I then reversed the right array into descending density order and pushed it into the left array, flattening it to give the new rearranged fragment order. I am assuming here that the fragments with the highest densities should be in the middle of the distribution, with fragments of lowest densities at either end, due to the normal distribution of SNPs along the sequence.</p>

<p>I expect this version of the L/R Method to perform better than the previous version (Method 2a), as I am now using the SNP density information to decide where each frag should be placed in the &ldquo;Left&rdquo; and &ldquo;Right&rdquo; arrays, where previously this was based on the position of the fragments within the fasta file (which is random). I do however also expect this method to have a high ordinal similarity score. Whilst I am as yet unsure of how well the &ldquo;skew&rdquo; of SNP positions within a fragment can be used to tell which side of the sequence it is from (due to the normal distribution), I am still using the &ldquo;Even Odd Method&rdquo; to place the fragments with 0 SNPs in the &ldquo;Left&rdquo; or &ldquo;Right&rdquo;. Since the order of the fragments with 0 SNPs is essentially random, the Even Odd Method does not neccesarily put them on the correct end of the rearranged order, let alone in the correct position.</p>

<h3>Method 2c: Another l/r method idea</h3>

<p>Another idea I had was to run method 2a, then re-order each of the left and right lists individually according to SNP density. I decided this would not be worth the time it took to code, as the rearrangement it produces should logically be identical to the order of the fragments from Method 2b.</p>
</blockquote>

<h2>Results</h2>

<h3>Ordinal Similarity Scores</h3>

<ol>
<li><p><strong>Highest Possible Score</strong>: 858,050</p></li>
<li><p><strong>C1 Density order</strong>: 624,196 </p></li>
<li><p><strong>C2 Random order</strong>: 571,132.5 (standard error: 1062.454) Standard error is low so mean is accurate</p></li>
<li><p>a. <strong>M1 a Even/Odd method</strong>: 492,838<br/>
b. <strong>M1 b Odd/Even method</strong>: 490,524</p></li>
<li><p><strong>M2 a Left Right Method</strong>: 570,434</p></li>
<li><p><strong>M2 b Left Right Density Method</strong>: 491,950</p></li>
</ol>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/rearrangement_methods.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/rearrangement_methods.png">Figure 3</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_o.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_o.png">Figure 4</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_c1.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_c1.png">Figure 5</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_c2.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_c2.png">Figure 6</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m1a.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m1a.png">Figure 7</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m1b.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m1b.png">Figure 8</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2al.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2al.png">Figure 9</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2ar.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2ar.png">Figure 10</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2a.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2a.png">Figure 11</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2bl.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2bl.png">Figure 12</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2br.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2br.png">Figure 13</a></p>

<p><img src="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2b.png?raw=true" alt="Image"/>
<a href="https://github.com/edwardchalstrey1/fragmented_genome_with_snps/blob/master/figures/d_m2b.png">Figure 14</a></p>

<blockquote>
<h3>Discuss</h3>

<ol>
<li><p><strong>Density order C1</strong>: A high score as expected</p></li>
<li><p><strong>Random order C2</strong>: The average score of 100 random arragements generated using the shuffle method of the Array Class in ruby. Conversion of integer to float for division (to get average) is the reason for the float score. Calling this multiple times gave scores roughly from 570,000 to 574,000. A more consistent &ldquo;average random score&rdquo; could be ascertained with a higher repeat number than 100, but is not neccesary (would increase the running time of the method). Error bars are shown on fig.2 for Control 2; these show very clearly that there is a low standard error, and that the score for random rearrangements does not vary greatly from the mean.</p></li>
<li><p><strong>Even Odd Method M1</strong>: As expected this method performed better than the controls, but still had a very high score. I have run it twice, with even indexes of the density order first, then odd indexes reversed and vice versa. The method gives a similar score whichever way around you do it: this is an important thing to note, as I use this method within later methods i.e. there is no need to always test even/odd AND odd/even. This method is flawed because whether or not a fragment is on an even index in the density ordered array has no bearing on that fragments&#39; position in the original order.</p></li>
<li><p><strong>Left Right Method M2a</strong>: As expected this method performed poorly. However, with a score similar to the average random order, it may not be likely that the &ldquo;skew&rdquo; of SNP positions is a good indicator of it&#39;s position in the original order.</p></li>
<li><p><strong>Left Right Density Method M2b</strong>: This method has a similar ordinal similarity score to the Even Odd Method. What this may suggest is that the &ldquo;skew&rdquo; of the SNP positions on a fragment is no better an indicator of the &ldquo;side&rdquo;&ldquo; of the sequence (where the centre of the normal distribution of SNPs is in the middle) than picking the side at random, as in the Even Odd method (whether a fragment is on an even or odd index in the density ordered array has no bearing on that fragments&#39; position in the original order). However, similar scores between the two methods could be because quite a large proportion of the fragments are still being ordered by the Even Odd method, in the Left Right Density Method (the fragments with 0 SNPs).</p></li>
</ol>
</blockquote>

</body>

</html>

